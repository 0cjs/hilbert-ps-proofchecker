''' A `Proof` is a list of axiom schema, a list of additional axioms (or
    "givens"), and a list of `Step`s, each of which is an `Axiom`
    instantiated from an axiom schema, a `Given` from the list of
    additional axioms, or a modus ponens inference `MP`.

    The `Step`s do not have specified formulae, but each one generates
    a formula based on its specified derivation:
    - the given axiom for a `Given`;
    - an axiom instantiated from a `Schema` via substitution for an `Axiom`;
    - a consequent of an MP inference that is the right-hand side of the
      major premise (a previous step) it references.

    The `Proof.valid` property is `True` or `False` depending on whether
    the proof is valid or not; each step also has a `Step.valid` property.
    All this really checks is that the minor premise of the `MP` steps
    matches the left hand side of the major premise; steps can otherwise be
    invalid only if improperly constructed (e.g., providing not enough or
    too many substitutions for an axiom schema, or referencing a step that
    doesn't exist before the current step) and it's not possible to
    instantiate such `Proof` objects as the constructor will throw an
    error in cases like this.
'''

from    formula  import *
from    schema  import Schema

from    abc  import abstractmethod, abstractproperty
from    typing  import Iterable, List, Optional

#   The problem asks for a system using one fixed list of axiom schema,
#   but I parametrize it here because I'd like to try out some different
#   ones later and parametrization is trivial to do.
#
AXIOMS = {
    'PS': tuple(map(Schema, (
        Im(φ, Im(ψ, φ)),                #             φ → (ψ → φ)
        Im(Im(φ, Im(ψ, χ)),             # (φ → (ψ → χ)) → ((φ → ψ) → (φ → χ))
           Im(Im(φ, ψ), Im(φ, χ))),
        Im(Im(No(ψ), No(φ)),            #     (¬ψ → ¬φ) → (φ → ψ)
           Im(   φ ,    ψ )),
    ))),
    'L': (
        Im(A, Im(B, A)),                #              A → (B → A)
        Im(Im(A, Im(B, C)),             #  (A → (B → C)) → ((A → B) → (A → C))
           Im(Im(A, B), Im(A, C))),
        Im(Im(No(B), No(A)),            #      (¬B → ¬A) → ((¬B → A) → B)
           Im(Im(No(B), A), B)),
    ),
}
''' A `dict` of axiom `Schema` tuples indexed by logic name.

    This includes:
    - ``PS``: Hilbert system PS,
    - ``L``: Propositional calculus System L from Chapter 1 of Hirst and
      Hirst, *A Primer for Logic and Proof.*
'''
#   XXX It would be really nice for the above to verify with truth tables
#   that the axioms are tautologies.

####################################################################
#   Steps

class Step():
    ''' A step within a `Proof`.

        (This is abstract; only the subclasses are instantiated.)
    '''

    def __init__(self):
        #   The link back to the Proof and the step number is filled
        #   when a Step is added to a Proof. Given that use of a Step
        #   independent of a Proof is not really a normal thing, and
        #   with any such use we're fine with a runtime exception and
        #   traceback, we save ourself coding and checking effort elsewhere
        #   and don't type these as being allowed to be None. (These are
        #   essentially private attributes of the Proof class.)
        self._proof:"Proof" = None      # type:ignore [assignment]
        self._step:int      = None      # type:ignore [assignment]

    @abstractmethod
    def __repr__(self): ...     # So we don't forget to implement this.

    @property
    def proof(self):
        ' The `Proof` containing this step. '
        return self._proof

    @property
    def step(self):
        ''' This step's ordinal number (starting with 1) within the `Proof`
            containing this step.
        '''
        return self._step

    @abstractproperty
    def fm(self) -> Fm:
        ' The formula generated by this step. '

    @abstractproperty
    def valid(self) -> bool:
        ' Whether this step within a proof is valid. '

class Given(Step):
    ''' A use of an assumption given as part of a proof,
        i.e., a Gₙ from the list G₁, G₂, … ⊢ P.

        Assumption formulae must be used exactly as-is; no substitution is
        allowed.

        (This is named `Given` because it is more easily distinguished
        from `Axiom` than `Assumption`. It also happens to make for
        easier completion.)
    '''
    def __init__(self, index:int):
        self._index = index
        super().__init__()

    def __repr__(self) -> str:
        return 'Given(' + str(self.index) + ')'

    @property
    def index(self) -> int:
        ''' Index (1-based) in the list of assumptions given to this step's
            `Proof`.
        '''
        return self._index

    @property
    def fm(self) -> Fm:
        return self._proof.given(self.index)

    @property
    def valid(self) -> bool:
        ''' A `Given` line is always valid. (That it references one of the
            `givens` of the proof is checked during `Proof` construction.)
        '''
        return True             # already validated in Proof._validate()

class Axiom(Step):
    ''' A use of an axiom as a step in a `Proof`. The axiom is generated
        from the specified index of an axiom `Schema` and a list (any
        `Iterable`) of formulae `Fm` to be substituted for each metavariable.
    '''

    #   XXX Surely there's a more concise way of dealing with the
    #   substitutions iterable being optional.
    def __init__(self, index:int, substitutions:Optional[Iterable[Fm]]=None):
        self._index:int = index
        if substitutions is None:
            self._substitutions = None
        else:
            self._substitutions = tuple(substitutions)
        self._fm:Optional[Fm] = None

    def __repr__(self) -> str:
        i = str(self._index)
        if self._substitutions is None:
            sb = ''
        else:
            sb = ',(' + ','.join(map(str, self._substitutions)) + ')'
        return f'Axiom({i}{sb})'

    @property
    def index(self) -> int:
        ''' Index (1-based) in the list of axiom schema given to this
            step's `Proof`.
        '''
        return self._index

    @property
    def fm(self) -> Fm:
        if self._fm is None:        # lazy instantiation
            self._fm = self._proof \
                .axiom_schema(self._index).sub(self._substitutions)
        return self._fm

    @property
    def valid(self) -> bool:
        ''' An `Axiom` line is always valid. (That it references one of the
            axiom `Schema` of the proof is checked during `Proof`
            construction.)
        '''
        return True

class MP(Step):
    ''' A use of the modus ponens inference as a step in a `Proof`.
    '''

    class MPError(ValueError):
        ' Major premise main connective is not an implication. '

    def __init__(self, min:int, maj:int):
        ''' A modus ponens step is a reference to two previous steps
            in the proof that together assert a formula.

            The first step is the minor premise (`min`) which asserts
            anything. This must match the antecedent of the major premise.

            The second step is the major premise (`maj`), which is split
            into two parts: the *antecedent* (the left branch from the
            dyadic connective at the root of the AST) and the *consequent*
            (the right branch).

            If the formula of `min` matches the antecedent of `maj`, this
            step produces the consequent of `maj` as its formula.

            Note that there is no substitution involved here; both the
            structure and the variables in `min` and `maj`'s antecedent
            must match exactly.

            (The terminology for this was taken from `Metamath`_ and the
            `Modus ponens`_ Wikipedia page.)

            .. _Metamath: https://us.metamath.org/mpeuni/ax-mp.html
            .. _Modus ponens: https://en.wikipedia.org/wiki/Modus_ponens

        '''
        self._min:int = min
        self._maj:int = maj
        super().__init__()

    def __repr__(self) -> str:
        return f'MP({self.min},{self.maj})'

    @property
    def min(self) -> int:
        'The step number of the minor premise.'
        return self._min

    @property
    def maj(self) -> int:
        'The step number of the major premise.'
        return self._maj

    @property
    def minfm(self) -> Fm:
        ' The formula of the minor premise. '
        return self._proof.step(self.min).fm

    @property
    def majfm(self) -> Fm:
        ''' The formula of the major premise. This *must* have an
            implication (``→``) as the main connective (i.e. at the root of
            the AST) that divides it into an antecedent and a consequent.
            If it does not, an `MPError` will be raised.
        '''
        f = self.proof.step(self.maj).fm
        if f.value != '→':
            raise self.MPError('Major premise main connective'
                f' is not an implication (→): {f}')
        return f

    @property
    def antecedent(self) -> Fm:
        return self.majfm.left

    @property
    def consequent(self) -> Fm:
        return self.majfm.right

    @property
    def fm(self) -> Fm:
        return self.consequent

    @property
    def valid(self) -> bool:
        return self.minfm == self.antecedent

####################################################################
#   Proofs

class Proof:
    ''' A proof is a list of axiom schema (`Schema`), a list of additional
        axioms (`Given`s) and a list of steps.

        The first two may be supplied as any `Iterable`. The third is an
        `Iterable` of pairs (2-`tuple`s) of an `int` step number and a
        `Step` object. See `StepsArg` below for more details.

        A `Proof` instantiation does not (currently) include the final
        formula that is expected to be what the proof asserts; the
        assertion is derived from the final step definition. While this can
        be compared with the expected formula outside the `Proof` object,
        it might make sense to add the expected formula to the constructor
        here and have `valid` check that against the actual formula
        produced by the proof.
    '''

    StepsArg = Iterable[tuple[int, Step]]
    ''' The steps given to a `Proof` are an `Iterable` consisting of
        pairs of ``(int, Step)``, where the `int` is a step number
        monotonically increasing from 1.

        This is for ease of writing in Python: it lets you easily see when
        constructing a `Proof` object the number of each step so that you
        can correctly reference previous steps in the proof. (All
        references must be to previous steps; forward references are not
        allowed.)
    '''

    def __init__(self,
        axiom_schema:Iterable[Schema],
        givens:Iterable[Fm],
        steps:StepsArg
    ):
        self._axiom_schema:tuple[Schema, ...] = tuple(axiom_schema)
        self._givens:tuple[Fm, ...] = tuple(givens)
        self._steps:tuple[Step, ...] = self._countsteps(steps)

    class StepError(ValueError):
        ' The sequence of steps was not monotonically increasing from 1. '

    class InternalError(RuntimeError): '@private'

    def _countsteps(self, ss:StepsArg) -> tuple[Step, ...]:
        ei = 1; steps:List[Step] = []
        for i, s in ss:
            if i == ei:
                ei += 1
                steps.append(self._validate(i, s))
            else:
                raise self.StepError(
                    f'Expected step {ei} but got step {i}: {s}')
        if len(steps) == 0:
            raise ValueError('steps may not be empty')
        return tuple(steps)

    def _validate(self, i:int, s:Step) -> Step:
        ''' Validate `s` as step `i` of this `Proof` and return it updated
            with the step number and a reference to this Proof.

            This ensures that `Axiom`s and `Given`s reference an axiom
            schema or given that's a part of this proof, that `MP`s
            reference previous proof steps, and the like.

            Each step is given its step number and a reference back to its
            proof so that it can get its formula, etc. from the proof's
            axiom schema, givens, and other steps.
        '''
        if isinstance(s, Given):
            try:  self.given(s.index)
            except IndexError:  raise self.StepError(f'Step {i} {s}'
                f' references non-existent Given index {s.index}')
        elif isinstance(s, Axiom):
            try:  self.axiom_schema(s.index)
            except IndexError:  raise self.StepError(f'Step {i} {s}'
                f' references non-existent axiom Schema index {s.index}')
        elif isinstance(s, MP):
            prev = range(1, i)        # does not include this step!
            if not s.min in prev or not s.maj in prev:
                raise self.StepError(
                    f'Step {i} {s} references non-existent previous steps')
        else:
            raise self.InternalError()

        s._proof = self
        s._step = i
        return s

    def axiom_schema(self, n:int) -> Schema:
        ''' Return the `n`th axiom schema in the list of axiom schema
            available to this proof.

            Note that indicies start at 1, not 0.
        '''
        return self._axiom_schema[n-1]

    def given(self, n:int) -> Fm:
        ''' Return one of the additional addtional axioms (also called
            hypotheses) for the proof. I.e., the Gₙ of G₁, G₂, … ⊢ P.

            Note that indicies start at 1, not 0.
        '''
        return self._givens[n-1]

    def step(self, n:int) -> Step:
        ''' Return step `n` of the proof.

            Note that step numbers start at 1, not 0.
        '''
        return self._steps[n-1]

    @property
    def steps(self) -> tuple[tuple[int, Step], ...]:
        ' Return all steps of the proof, with their step numbers. '
        stepnums = range(1, len(self._steps) + 1)
        return tuple((i,s) for i, s in zip(stepnums, self._steps))

    @property
    def assertion(self) -> Fm:
        ' The formula that the final step of the proof asserts. '
        return self.step(len(self._steps)).fm

    @property
    def valid(self) -> bool:
        ' `True` if the proof is valid, `False` if not. '
        return all(map(lambda s: getattr(s, 'valid'), self._steps))

    def __str__(self) -> str:
        return '\n'.join(
            f'{i}:  ⊢ {str(s.fm):52} {"from " + str(s):>20}'
                for i, s in self.steps
        )
