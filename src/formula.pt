from    binarytree  import Node
from    formula  import *
import  pytest

p_ = pytest.mark.parametrize

####################################################################
#   Node types

@p_('x', ['a', 'A', 'x', 'φ', 'Ξ', 1, 2, Node('φ')])
def test_nodetype_var(x):
    assert F.nodetype(x) is F.VAR

@p_('x', ['¬', Node('¬')])
def test_nodetype_monadic(x):
    assert F.nodetype(x) is F.MONADIC

@p_('x', ['→', '↔', '∧', '∨', '+', '*', Node('→')])
def test_nodetype_dyadic(x):
    assert F.nodetype(x) is F.DYADIC

@p_('x', ['->', 0, '3', None, ])
def test_nodetype_bad(x):
    with pytest.raises(ValueError): F.nodetype(x)


####################################################################
#   ASTs

def test_F():
    ''' A couple of extremely simple tests because the majority of Node
        construction behviour is tested in the Node validation above, and
        much of the tree behviour is exercised by tests for things even
        like `__repr__()` or `__eq()__`.

        The three simple correct cases we need to cover are just a
        single variable, a monadic function, and a dyadic function.
    '''
    f = F('α'); t = f._tree
    assert ('α', None, None) == (t.value, t.left, t.right)

    f = F('¬', None, 'β'); t = f._tree
    assert (    '¬',   None,           'β',         None,          None) \
        == (t.value, t.left, t.right.value, t.right.left, t.right.right)

    f = F('→', 'α', 'β'); t = f._tree
    assert (    '→',          'α',           'β') \
        == (t.value, t.left.value, t.right.value)
    assert (       None,         None,         None,          None) \
        == (t.left.left, t.left.right, t.right.left, t.right.right)

@p_('x, y', [
    (      'a',       'b'),
    (Node('a'), Node('b')),
    (   F('a'),    F('b')),
])
def test_F_nodify(x, y):
    ''' Ensure we can pass single values, `binarytree.Node` values
        and `F` values to the `F` constructor.
    '''
    f = F('→', x, y);
    assert ('a', 'b') == (f._tree.left.value, f._tree.right.value)

@p_('arg0, arg1, arg2, msgfrag', [
    ('α',    1, None, 'may not have children'),
    ('α', None,    2, 'may not have children'),
    ('¬', None, None, 'must have only right child'),
    ('¬',    1,    2, 'must have only right child'),
    ('→', None, None, 'must have two children'),
    ('→', None,    2, 'must have two children'),
    ('→',    1, None, 'must have two children'),
])
def test_F_errors(arg0, arg1, arg2, msgfrag):
    with pytest.raises(ValueError) as ex: F(arg0, arg1, arg2)
    assert ex.match(msgfrag)

def test_NO():
    f = NO('φ'); t = f._tree
    assert ('¬',       None,           'φ',         None,          None) \
        == (t.value, t.left, t.right.value, t.right.left, t.right.right)

    f = NO(F('→', 'a', 'b')); t = f._tree
    print(t)
    assert ('¬', '→', 'a', 'b') \
        == (t.value, t.right.value, t.right.left.value, t.right.right.value)

@p_('s, x', [
    ("F('φ')",                      F('φ')),
    ("F('→', F('a'), F('b'))",      F('→', 'a', 'b')),
    ("F('¬', right=F('∧', F('a'), F('∨', F('b'), F('c'))))",
                            (F('¬', None, F('∧', 'a', F('∨', 'b', 'c'))))),
])
def test_repr(s, x): assert s == repr(x)

@p_('eq, x, y', [
    (False,  F('φ'),                None),
    (False,  F('φ'),                NO('φ')),
    (False,  F('φ'),                F('→', 'φ', 'φ')),
    ( True,  F('φ'),                F('φ')),
    ( True,  F('→', NO('a'), 'b'),  F('→', NO('a'), 'b')),
    #   Actually, these two are technically equal in the sense we probably
    #   want, because the variables are the same under subtitution.
    #   See the docstring for more details.
    (False,  F('φ'),                NO('ψ')),
])
def test_F_eq(eq, x, y): assert eq is (x == y)

@p_('s, f', [
    ('φ',       F('φ')),
    ('2',       F(2)),
    ('¬ψ',      NO('ψ')),
    ('p → q',   F('→', 'p', 'q')),
    ('¬b → a',  F('→', NO('b'), 'a')),
    ('(φ → (ψ → χ)) → ((φ → ψ) → (φ → χ))',
                F('→', F('→', 'φ', F('→', 'ψ', 'χ')),
                       F('→', F('→', 'φ', 'ψ'), F('→', 'φ', 'χ')))),
    ('(A ∧ B) → ¬(A → ¬B)',
                F('→', F('∧', 'A', 'B'), NO(F('→', 'A', NO('B'))))),
    #   Might as well get some practice typing in something complex. :-P
    ('((((A → B) → (¬C → ¬D)) → C) → E) → ((E → A) → (D → A))',
                F('→',
                    F('→', F('→',
                        F('→', F('→', 'A', 'B'),
                               F('→', NO('C'), NO('D'))),
                        'C'), 'E'),
                    F('→', F('→', 'E', 'A'), F('→', 'D', 'A')))),

])
def test_F_str(s, f): assert s == str(f)
