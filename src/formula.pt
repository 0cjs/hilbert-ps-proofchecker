from    binarytree  import Node
from    formula  import *
import  pytest

p_ = pytest.mark.parametrize

####################################################################
#   Value types

@p_('x', ['a', 'A', 'x', 'φ', 'Ξ', Node('φ'), Fm('φ'), φ, A, ])
def test_valtype_var(x):
    assert Fm.valtype(x) is Fm.VAR

@p_('x', ['¬', Node('¬'), Fm('¬', None, φ), ])
def test_valtype_monadic(x):
    assert Fm.valtype(x) is Fm.MONADIC

@p_('x', ['→', '↔', '∧', '∨', '+', '*', Node('→'), Fm('→', ψ, φ), ])
def test_valtype_dyadic(x):
    assert Fm.valtype(x) is Fm.DYADIC

@p_('x', ['->', 0, '3', None, ])
def test_valtype_bad(x):
    with pytest.raises(ValueError): Fm.valtype(x)


####################################################################
#   ASTs

def test_F_inst_str():
    ''' A couple of extremely simple tests because the majority of Node
        construction behviour is tested in the Node validation above, and
        much of the tree behviour is exercised by tests for things even
        like `__repr__()` or `__eq()__`.

        The three simple correct cases we need to cover are just a
        single variable, a monadic function, and a dyadic function.
    '''
    f = Fm('α'); t = f._tree
    assert ('α', None, None) == (t.value, t.left, t.right)

    f = Fm('¬', None, 'β'); t = f._tree
    assert (    '¬',   None,           'β',         None,          None) \
        == (t.value, t.left, t.right.value, t.right.left, t.right.right)

    f = Fm('→', 'α', 'β'); t = f._tree
    assert (    '→',          'α',           'β') \
        == (t.value, t.left.value, t.right.value)
    assert (       None,         None,         None,          None) \
        == (t.left.left, t.left.right, t.right.left, t.right.right)

def test_Fm_inst_Fm():
    ''' Test instantiation of F where the `vc` is a Formula, rather
        than just a string or int.
    '''
    assert 'φ' == Fm(Fm('φ'))._tree.value

@p_('x, y', [
    (      'a',       'b'),
    (Node('a'), Node('b')),
    (  Fm('a'),   Fm('b')),
])
def test_F_nodify(x, y):
    ''' Ensure we can pass single values, `binarytree.Node` values
        and `Fm` values to the `Fm` constructor.
    '''
    f = Fm('→', x, y);
    assert ('a', 'b') == (f._tree.left.value, f._tree.right.value)

@p_('arg0, arg1, arg2, msgfrag', [
    ('α',  'A', None, 'may not have children'),
    ('α', None,  'B', 'may not have children'),
    ('¬', None, None, 'must have only right child'),
    ('¬',  'A',  'B', 'must have only right child'),
    ('→', None, None, 'must have two children'),
    ('→', None,  'B', 'must have two children'),
    ('→',  'A', None, 'must have two children'),
])
def test_F_errors(arg0, arg1, arg2, msgfrag):
    with pytest.raises(ValueError) as ex: Fm(arg0, arg1, arg2)
    assert ex.match(msgfrag)

@p_('s, x', [
    ("Fm('φ')",                         Fm(φ)),
    ("Fm('φ')",                         φ ),
    ("Fm('→', Fm('a'), Fm('b'))",       Fm('→', 'a', 'b')),
    ("Fm('¬', right=Fm('∧', Fm('a'), Fm('∨', Fm('b'), Fm('c'))))",
                            (Fm('¬', None, Fm('∧', 'a', Fm('∨', 'b', 'c'))))),
])
def test_repr(s, x): assert s == repr(x)

@p_('eq, x, y', [
    (False,  Fm(φ),                 None),
    (False,  Fm(φ),                 No(φ)),
    (False,  Fm(φ),                 Fm('→', φ, φ)),
    ( True,  Fm(φ),                 Fm(φ)),
    ( True,  Fm('→', No('a'), 'b'), Fm('→', No('a'), 'b')),
    #   Actually, these two are technically equal in the sense we probably
    #   want, because the variables are the same under subtitution.
    #   See the docstring for more details.
    (False,  Fm(φ),                No(ψ)),
])
def test_F_eq(eq, x, y): assert eq is (x == y)

@p_('s, f', [
    ('φ',       Fm(φ)),
    ('¬ψ',      No(ψ)),
    ('p → q',   Fm('→', 'p', 'q')),
    ('¬b → a',  Fm('→', No('b'), 'a')),
    ('(φ → (ψ → χ)) → ((φ → ψ) → (φ → χ))',
                Fm('→', Fm('→',             φ, Fm('→', ψ, χ)),
                        Fm('→', Fm('→', φ, ψ), Fm('→', φ, χ)))),
    ('(A ∧ B) → ¬(A → ¬B)',
                Fm('→', Fm('∧', A, B), No(Fm('→', A, No(B))))),
    #   Might as well get some practice typing in something complex. :-P
    ('((((A → B) → (¬C → ¬D)) → C) → E) → ((E → A) → (D → A))',
                Fm('→',
                   Fm('→', Fm('→',
                      Fm('→', Fm('→', A, B),
                              Fm('→', No(C), No(D))),
                      C),  E),
                    Fm('→', Fm('→', E, A), Fm('→', D, A)))),

])
def test_F_str(s, f): assert s == str(f)

####################################################################
#   Convenience constructors
#
#   Since we've already confirmed above that `Fm.__str__()` is working,
#   we can take the easy way out here and simply test that convenience
#   constructors through that.

@p_('s, arg', [
    ('¬φ',             φ),
    ('¬¬φ',         No(φ)),
    ('¬(A → B)',    Im(A, B))
])
def test_No(s, arg):
    assert s == str(No(arg))

#   f = No(φ); t = f._tree
#   assert (    '¬',   None,           'φ',         None,          None) \
#       == (t.value, t.left, t.right.value, t.right.left, t.right.right)

#   f = No(Fm('→', 'a', 'b')); t = f._tree
#   print(t)
#   assert ('¬', '→', 'a', 'b') \
#       == (t.value, t.right.value, t.right.left.value, t.right.right.value)

@p_('s, antecedent, consequent', [
    ('ψ → φ',        ψ, φ),
    ('φ → (ψ → φ)',  φ, Im(ψ, φ)),
])
def test_Im(s, antecedent, consequent):
    assert s == str(Im(antecedent, consequent))
